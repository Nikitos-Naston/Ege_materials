"""
PYTHON — КОЛЛЕКЦИИ И ФУНКЦИИ
Списки, словари, множества, массивы (коротко) + свои и встроенные функции
Используй как памятку и шаблон для практики
"""

# =============================================================================
# 1. СПИСКИ (list)
# =============================================================================
# Список — упорядоченная изменяемая коллекция.
nums = [3, 5, 8]
words = ["cat", "dog"]
mixed = [1, "hi", True]

# Индексация и срезы
first = nums[0]       # 3
last = nums[-1]       # 8
part = nums[0:2]      # [3, 5]

# Изменяемость
nums[1] = 6           # [3, 6, 8]
nums.append(10)       # [3, 6, 8, 10]
nums.insert(1, 100)   # [3, 100, 6, 8, 10]
nums.remove(100)      # [3, 6, 8, 10]
popped = nums.pop()   # удаляет последний → 10

# Полезное
length = len(nums)    # длина списка
exists = 6 in nums    # True
nums.extend([1, 2])   # добавление нескольких

# Итерация
for x in nums:
    print(x)

# Генераторы списков (списковые включения)
squares = [i*i for i in range(1, 6)]  # [1,4,9,16,25]
evens = [i for i in range(10) if i % 2 == 0]

# Сортировка
a = [5, 2, 9, 1]
a.sort()              # изменяет на месте → [1,2,5,9]
b = sorted([5, 2, 9]) # новая отсортированная копия

if 5 in a:
    print("YES") # напечатает да

if 3 in a:
    print("YES") # ничего не напечатает

# Практика:
# 1) Ввод k, затем k чисел → собрать в список, вывести сумму и среднее.
# 2) Дан список чисел → оставить только уникальные, сохранить порядок (подсказка: set для проверки, новый список для результата).
# 3) Таблица квадратов для 1..n как список пар (i, i*i).


# =============================================================================
# 2. СЛОВАРИ (dict)
# =============================================================================
# Словарь — отображение ключ → значение. Ключи обычно строки или числа.
user = {"name": "Nika", "age": 12}
print(user["name"])           # доступ по ключу
user["age"] = 13              # изменение значения
user["city"] = "Moscow"       # добавление пары
age = user.get("age", 0)      # безопасный доступ с дефолтом
exists_key = "name" in user   # True
removed = user.pop("city", None)  # удалить ключ, если есть

# Итерация
for key in user:
    print(key, user[key])
for key, val in user.items():
    print(key, val)
for val in user.values():
    print(val)

# Словарь из списков/пар
pairs = [("a", 1), ("b", 2)]
d = dict(pairs)               # {"a":1, "b":2}
counts = {}
for ch in "banana":
    counts[ch] = counts.get(ch, 0) + 1  # подсчёт частот

# Практика:
# 1) Словарь товаров: имя → цена; посчитать стоимость корзины по списку покупок.
# 2) Подсчитать частоты слов в строке (split()), найти слово‑лидер.
# 3) Инвертировать словарь (если значения уникальны): val → key.

# =============================================================================
# 3. МНОЖЕСТВА (set)
# =============================================================================
# Множество — неупорядоченная коллекция уникальных элементов.
# Литерал: {э1, э2, ...} или set() для пустого множества.
s = {1, 2, 2, 3}
print(s)               # {1, 2, 3}
s.add(4)
has1 = 1 in s          # True
size = len(s)

# Операции множеств
a = {1, 2, 3}
b = {3, 4, 5}
u = a | b              # объединение {1,2,3,4,5}
i = a & b              # пересечение {3}
d = a - b              # разность {1,2}
sx = a ^ b             # симметрическая разность {1,2,4,5}

# Применение: убрать дубликаты
unique_nums = list(set([1, 2, 2, 3, 3, 3, 4]))

# Практика:
# 1) Даны два списка имён: найти общих (пересечение) и уникальных (симметрическая разность).
# 2) Проверить, все ли символы строки уникальны (через set сравнить длины).
# 3) Построить множество букв в тексте, убрать пробелы и пунктуацию.


# =============================================================================
# 4. ФУНКЦИИ: ПОЛЬЗОВАТЕЛЬСКИЕ (def)
# =============================================================================
# Объявление:
def greet(name):
    print("Привет,", name)

greet("Мир")

# Возврат значения:
def add(a, b):
    return a + b

# Параметры по умолчанию:
def power(x, p=2):
    return x ** p

# Именованные аргументы:
val = power(x=3, p=3)

# Несколько возвратов (кортеж):
def min_max(lst):
    return min(lst), max(lst)

mn, mx = min_max([3, 1, 8])

# Области видимости: параметры и локальные переменные живут внутри функции.

# Докстрока:
def area_circle(r):
    """Вычисляет площадь окружности по радиусу r."""
    from math import pi
    return pi * r * r

# Аннотации типов (подсказки, не проверяются в рантайме):
def clamp(x: float, lo: float, hi: float) -> float:
    if x < lo: 
        return lo
    if x > hi: 
        return hi
    return x

# Практика:
# 1) sum_pos(lst): сумма только положительных.
# 2) is_prime(n): проверка простоты (делители до sqrt(n)).
# 3) normalize(words): привести к нижнему регистру и убрать пустые.

# =============================================================================
# 5. ВСТРОЕННЫЕ ФУНКЦИИ И ПОЛЕЗНЫЕ СТАНДАРТНЫЕ
# =============================================================================
# Частые встроенные:
# len(x), sum(iterable), min(...), max(...), sorted(iterable),
# list(), dict(), set(), tuple(), int(), float(), str(),
# range(), enumerate(iterable), zip(a, b), map(func, iterable),
# filter(func, iterable), any(iterable), all(iterable)

nums = [3, 1, 4, 1, 5]
print(len(nums))              # 5
print(sum(nums))              # 14
print(sorted(nums))           # [1,1,3,4,5]
print(list(enumerate(nums)))  # [(0,3),(1,1),...]

# enumerate: индекс+значение
for i, x in enumerate(nums, start=1):
    print(i, x)

# zip: объединение парами
xs = [1, 2, 3]
ys = [10, 20, 30]
pairs = list(zip(xs, ys))     # [(1,10),(2,20),(3,30)]

# any/all:
flags = [True, True, False]
print(any(flags))  # True, если хотя бы одно True
print(all(flags))  # True, если все True

# map/filter + lambda:
doubles = list(map(lambda t: t * 2, xs))           # [2,4,6]
only_even = list(filter(lambda t: t % 2 == 0, xs)) # [2]

# Практика:
# 1) Даны два списка одинаковой длины: сделать список попарных сумм через zip/map.
# 2) Посчитать долю чётных чисел (all/any не забудь).
# 3) Отсортировать список словарей по полю "score" убыванием.


# =============================================================================
# 7. НЕБОЛЬШАЯ ПРАКТИКА (смешанные)
# =============================================================================
# (A) normalize_dict: строка → словарь частот букв (только a..z, без пробелов)
# (B) unique_words: строка → отсортированный список уникальных слов в нижнем регистре
# (C) top_k(d, k): из словаря {ключ: число} вернуть список k ключей с макс значениями
# (D) flatten: “сплющить” список списков [[1,2],[3]] → [1,2,3]
# (E) merge_scores: объединить два словаря суммируя совпадающие ключи

# Подсказки:
# - Для (A) используй dict.get() и .isalpha()
# - Для (B) split(), set(), sorted()
# - Для (C) sorted(d.items(), key=lambda p: p[1], reverse=True)[:k]
# - Для (D) двойной for или sum(lists, [])
# - Для (E) скопировать один словарь и пройтись по второму, складывая

# =============================================================================
# 8. ЧАСТЫЕ ОШИБКИ
# =============================================================================
# - Путают копию списка и ссылку: b = a копирует ссылку; для копии делай a.copy() или a[:]
# - Удаление в списке во время итерации — лучше формировать новый список.
# - Перебор dict без .items(): помни, что по умолчанию идёшь по ключам.
# - Множества не сохраняют порядок (встроенные set упорядочивания не гарантируют).
# - Не изменяй список, который сортируешь, если нужна исходная версия — используй sorted().


# =============================================================================
# 1. СТРОКИ И ФОРМАТИРОВАНИЕ
# =============================================================================
# Базовые операции:
text = "  Hello, Python!  "
print(text.strip())         # убрать пробелы по краям
print(text.lower())         # в нижний регистр
print(text.upper())         # в верхний регистр
print(text.replace("Python", "World"))  # замена подстроки
print(text.count("l"))      # количество вхождений символа/подстроки
print(text.find("Python"))  # индекс первого вхождения или -1

# split / join:
line = "a,b,c,,d"
parts = line.split(",")     # ['a','b','c','','d']
clean = "-".join(["x", "y", "z"])  # 'x-y-z'

# Срезы строк (как у списков):
s = "abcdefg"
print(s[:3])    # 'abc'
print(s[2:5])   # 'cde'
print(s[::-1])  # 'gfedcba' — разворот

# Проверки:
print("123".isdigit())   # True
print("abc".isalpha())   # True
print("ab12".isalnum())  # True
print("   ".isspace())   # True
print("Hello".startswith("He"))  # True
print("Hello".endswith("lo"))    # True
